## 产生雪崩的原因：
缓存雪崩通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。

## 基本解决思路如下：

* 第一，大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，避免缓存失效时对数据库造成太大的压力，虽然能够在一定的程度上缓解了数据库的压力但是与此同时又降低了系统的吞吐量。

* 第二，分析用户的行为，尽量让缓存失效的时间均匀分布。

* 第三，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。

## Redis雪崩效应的解决方案：

* 1、可以使用分布式锁，单机版的话本地锁

* 2、消息中间件方式

* 3、一级和二级缓存Redis+Ehchache

* 4、均摊分配Redis的key的失效时间

## 解释：

* 1、 使用锁处理

当突然有大量请求到数据库服务器时候，进行请求限制。使用所的机制，保证只有一个线程（请求）操作。否则进行排队等待（集群分布式锁，单机本地锁）。减少服务器吞吐量，效率低。

加入锁！

![](./images/加锁策略.png)

保证只能有一个线程进入 实际上只能有一个请求在执行查询操作

也可以在此处进行使用限流的策略~

* 2、使用消息中间件解决

这种方案是**最靠谱**的方案！

消息中间件可以解决高并发！！！

如果大量的请求进行访问时候，Redis没有值的情况，会将查询的结果存放在消息中间件中（利用了MQ异步步特性）

  1、大量请求过来，出现雪崩，也就是大量key失效，这时候怎么处理？
  
     将失效的key丢到队列如MQ、Kafka，并返回默认值或者空值。
        
  2、怎么处理队列如MQ Kafka的数据？
  
     消费队列的数据，查找DB库，若存在则缓存到redis;不存在,则结束操作。
     
  3、外界第二次大量请求过来，会怎么样？
  
     经过 第二步 操作，请求查缓存，若有值直接返回，没有值则丢到 队列，并返回默认值。
     
![](./images/redis雪崩.png)

**队列结构：**

![](./images/中间件策略.png)

* 3、做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）

* 4、不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

https://www.php.cn/redis/424918.html
